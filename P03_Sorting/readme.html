<meta charset="utf-8" lang="en">  <!-- this line allows UTF-8 characters in the .html file -->

                    **P03_Sorting**


<!--

General
========

For each of your team's implementations, explain the following (where appropriate and applicable):

- details on calling conventions, input and output data formats, limitations, bugs, and special features.
- negative aspects of your program (limitations, known bugs)
- positive aspects (extensions, special features)
- describe your choice of modularization (abstractions), data structures, and algorithms
- explain anything you did that is likely to be different from what other students may have done
- justify any design decisions for which the rationale isn't immediately clear

Feel free to modify the structure of this `readme.html` file to fit the current assignment and to fit how you wish to present your findings.


!!! note: Math Typesetting
    Surround your math with double dollar signs to have [MathJax](https://www.mathjax.org/) typeset it beautifully.
    To add a tilde in math mode (using dollar signs), use the `\sim` command.
    If an exponent has more than one character, you must surround it with curly braces.
    In the example below, the exponent for $T$ must use curly braces, but they aren't required for $N$.

    $$ \sim T^{1.2} N^2 $$

    Note: Typesetting like this is optional; feel free to use plain text if you'd like.


Submission
-----------

Use the CSE LogHistory Plug-in to create a zip file containing all your code, this `readme.html` document, and any additional files of evidence (ex: screenshots).
If you create a zip by other means, it will include all the files under `tests` and might miss some important files (ex: `.log/history.log`).
The former will make for a very large zip file; the latter will cause you to lose points.


-->



Author
=============


<!-- fill out the following table with your information -->
<!-- Note: wrapping table in div.noheader will hide the table's header -->
<!-- Note: wrapping table in div.firstcol will style the first column different from other columns -->
<div class="noheader firstcol">
                  |             
------------------|-------------
name              | Heather Dalton
computer + OS     | Lab + Linux
time to complete  | 27 hrs
partner           | N/A
additional help   | See Reflection
</div>




Implementations
===================


Doubling Tests Implementation
--------------------------

<!--
Explain briefly how you implemented the doubling tests.
How did you check that your implementation was correct?
Include code listings, screenshots, diagrams, etc. if helpful.
-->
For each of the different types of sorting, I made two functions for each.
One function measured the amount of time it took to sort using the specific
type. While the other function found the average amount of time it took over
four different test. Then it would loop through doubling N each time it
iterated through. The main way that I checked to see if the code was working
or not was by testing it in main to make sure no unexpected errors presented
itself.


Linked-List Sort Implementation
------------------------------

<!--
Explain briefly how you implemented the linked-list sort?
How did you check that your implementation was correct?
Include code listings, screenshots, diagrams, etc. if helpful.
-->
How I would have implemented Linked-List's sort would be by using a "Natural
Merge sort to exploit pre-existing order by identifying naturally-occurring
runs." My plan was to first find a run by saying if the list.next is
greater than current keep track. Once the list.next is smaller place a
marker1 (if repeated==T then marker two). Next, I would find the next run
using the same idea as before. Then, I would compare the two lists and merge
them together (going through each list compare to see which is smaller).
Throughout this I would keep a pointer at the beginnign and end of each linked-
list. This process would repeat until the linked-list was sorted.


Median of 3/5 Implementation
-----------------------------------

<!--
Explain briefly how you modified the provided quick sort code to use the median of 3 and the median of 5.
How did you check that your implementation was correct?
Include code listings, screenshots, diagrams, etc. if helpful.
-->
For both the median 3/5 implementation I started off with the brute force
approach, where I found all the different cases that could occur and then
wrote out the code for that. Then to make the Median 5 implementation more
efficient, I used an idea given to me by Owen. He helped me see that by
comparing two items at a time and then setting a low and high value
a person is able to see what the outputted index should be.

Analysis
===============


Edge Cases
--------------------

<!--
Explain briefly what you learned or confirmed with the edge cases.
Do you think that you have thought of all possible pathological cases?
What do these cases say about the different sorting algorithms?
-->
With the five different sorting algorithms I made a function for each to test
what would happen if a user passed in a specific edge case. For each of these edge
cases I made a function that would construct each one. By creating these two functions
I was able to clearly see what would happen if a user would pass in an array with, for
example a size of one. Over all I learned that for the majority of these edge cases
the sorting code already had a catch that threw an error if it ever occurred. To be
honest, I don't think that I though of all the possible pathological cases becasue there
are so many different ones to account for, so I tested the main ones.


Runtime Analysis
---------------------

<!--
How much time (in seconds) do the following sorting algorithms take?
Use tilde notation.
Briefly justify your answers and show your work.
Do your findings agree with what is said in class?
If not, why do you think they differ?

Do not include the time required for the allocating and initializing the arrays!
-->

sorting algorithm | Tilda Notation
------------------|----------------
Bubble            |  $\sim0.6518 N$
Insertion         |  $\sim 0.5841 N$
Selection         |  $\sim 0.5220 N$
Shellsort         |  $\sim 0.4649 N$
Quicksort         |  $\sim 0.0939N$
QuickSortMedian3  |  $\sim 0.3493N$
QuickSortMedian5  |  $\sim 0.1984N$

To calculate the time it took through doubling test was by doing the log
of the largest N time / second largest N time. For the most part what these
test conclude is similar to what we talked about in class. The only difference
is most likely because I didn't do the best implementation for the time.

Known bugs / limitations
-------------------------

<!--
What bugs or limitations were troublesome?
What bugs or limitations still remain?
Are these bugs or limitations a problem in your implementation, algorithm, or something else?
How do you know that you did not miss a bug?
What additional tests did you run to ensure that your implementations are correct?
-->

Linked-list is the biggest bug and limitation that I have at this moment. At the
end I was able to understand what needed to be done, I just didn't have the
mental capacity these past two weeks to solve this difficult problem.



Reflection
===========

<!--
Describe whatever help (if any) that you received.
Don't include readings, lectures, but do include any help from people (including course staff, lab TAs, classmates, and friends) and attribute them by name.
How did you discuss the problem with others? (ex: white-board algorithms, looking over code for bugs, looking at print out results, etc.)
-->

With this project I got alot of whiteboard help from many different people.
Some names that I talked the most to thinking out the problems using whiteboards
was Kayla Rehwoldt, Owen Elliot, and Katey Averill. Before even logging into
the computer we whiteboarded out different ideas for each sorting algorithm.



<!--
Since this is an individual assignment, if you worked with a partner, assert below that the work you are turning in is your own work, and that you only did "whiteboard" work as a group.
Give one sentence explaining what each of you contributed.
If you used the code from the lab challenge, explain what is shared between you and your lab partner.
-->

I also got assistance from Dr. Denning. Even though I was unable to implement
the ideas we talked about for linked list, I was able to grasp a better
understanding of what needed to be done to complete the linked-list sorting
algorithm.



<!--
Describe any serious problems you encountered.
How much time did you spend writing new code, debugging code, thinking about the algorithms, discussing with someone else, running tests, writing comments and documentation, etc.?
List any other comments here.
Feel free to provide any feedback on how much you learned from doing the assignment, and whether you enjoyed doing it.
-->

A serious problem that I encountered during this project was the stress from
the past two weeks. I was overwhelmed by my personal life events that occurred
the past two weeks and was mentally drained.

writing new code: 12.5 hrs
debugging code: 4.5 hrs
thinking about the algorithms: 4 hrs
discussing with someone else: 2.5 hrs
running tests: 2 hrs
writing comments/documentation: 1.5 hrs

One thing that I wish was different about this project was if the beginning time started after midterm week. I think
that if the start time was moved people would have felt less stressed overall. I understand time is essential and limited,
but another suggestion I have is to not bring up another project application the last lab day a different project is due.
For example, say today was the last lab day for PO2_Sorting. In that first hour of lab time you explained the writeup of
PO3_Sorting. This gets a person looking ahead to the next project but their mind is split between the instruction and the
lab actually due the next day. The last thing that was hard for this lab was that the write up for this project wasn't
as clear as the previous for what was expected, specifically for doubling test and edge cases.

<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
    .md div.tilde { margin: 5px 0 20px; }
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `&#36;`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible");</script>
